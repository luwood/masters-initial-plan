%% Adaptado de 
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% Traduzido para o congresso de IC da USP
%%*****************************************************************************
% Não modificar

\documentclass[twoside,conference,a4paper]{IEEEtran}

%******************************************************************************
% Não modificar
\usepackage{IEEEtsup} % Definições complementares e modificações.
\usepackage[latin1]{inputenc} % Disponibiliza acentos.
\usepackage[english,brazil]{babel}
%% Disponibiliza Inglês e Português do Brasil.
\usepackage{latexsym,amsfonts,amssymb} % Disponibiliza fontes adicionais.
\usepackage{theorem} 
\usepackage[cmex10]{amsmath} % Pacote matemático básico 
\usepackage{url} 
%\usepackage[portuges,brazil,english]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage[pagebackref=true,breaklinks=true,letterpaper=true,colorlinks,bookmarks=false]{hyperref}
\usepackage[tight,footnotesize]{subfigure} 
\usepackage[noadjust]{cite} % Disponibiliza melhorias em citações.
%%*****************************************************************************

\begin{document}
\selectlanguage{brazil}
\renewcommand{\IEEEkeywordsname}{Palavras-chave}

%%*****************************************************************************

\urlstyle{tt}
% Indicar o nome do autor e o curso/nível (grad-mestrado-doutorado-especial)
\title{Plano de Pesquisa}
\author{%
 \IEEEauthorblockN{Luísa Madeira Cardoso}
}

%%*****************************************************************************

\maketitle

%%*****************************************************************************
% Resumo do trabalho
\begin{abstract}
Transformar uma implementação da ferramenta Treplica baseada em sincronia de Treplica no equivalente te um wait-free Treplica. A performance da implementação será comparada utilizando um benchmark para avaliar a contribuição de wait-freedom com a performance de replicação ativa. 

\end{abstract}

% Indique três palavras-chave que descrevem o trabalho
\begin{IEEEkeywords}
 Palavras-chave
\end{IEEEkeywords}

%%*****************************************************************************
% Modifique as seções de acordo com o seu projeto

\section{Introdução}
A replicação é um dos tópicos mais estudados na área de sistemas distribuídos. 
De modo geral o mecanismo é utilizado para prover tolerância a falhas ou melhorar a performance.

O termo \textit{state machine approach}\cite{lamport1978,lamport1984} é utilizado para designar métodos que utilizam a replicação para prover serviços tolerantes a falhas. A ideia fundamental por trás do conceito é simples: dado um conjunto de máquinas de estado que inicialmente se encontram em situações semelhantes, se um conjunto de comandos determinísticos for executado na mesma ordem em cada uma, então o estado final será o mesmo em todas\cite{schneider1990}. Deste modo, todas as instâncias de um serviço estarão replicadas consistentemente. 

Considerando que no âmbito de sistemas distribuídos a entrega dos comandos se dá por troca de mensagens, o desafio encontra-se então em garantir uma ordem global de recebimento das mesmas. A esta classe de algoritmos da-se o nome \textit{Total order broadcast}(TOB) ou \textit{Atomic broadcast}(ABCAST). 

Existem diversas implementações para o TOB \cite{schiper2004}. 
Algumas exploram a relação de equivalência ao problema de \textit{Consenso}\cite{chandra1996} e utilizam algoritmos como Paxos\cite{lamport1998} na solução.
Em linhas gerais o \textit{Consenso} se resume a garantir que processos cheguem a uma decisão comum e única, inclusive na presença de falhas.  

Treplica\cite{vieira2008} é uma ferramenta projetada para replicação ubíqua (transparente, relisiliente e eficiente) que utiliza uma implementação de \textit{Total order broadcast} baseada em \textit{Consenso} utilizando Paxos e Fast-Paxos\cite{lamport2006}. Este documento apresenta um plano de pesquisa para transformar uma implementação de Treplica baseada em sincronização em uma equivalente \textit{wait-free}.


\section{Trabalho Proposto}

Um dos aspectos criticos para a performance de qualquer implementação de \textit{TOB} é o tratamento de concorrência. \textit{TOBs} precisam lidar com diversos eventos concorrentes: recepção/transmissão de mensagens, eventos de controle e persistência de dados. 
Normalmente, a arquitetura que organiza todo este fluxo de eventos assíncronos é baseada em múltiplos processos ou \textit{threads} que compartilham estruturas de dados. Invariavelmente o acesso aos recursos compartilhados não pode ser realizado sem algum método de controle, visto que isso produziria um estado inconsistente. Mecanismos de sincronização são a principal forma de coordenação empregada nestes cenários. 
As primitivas básicas de sincronização em qualquer linguagem ou sistema operacional se baseiam em \textit{exclusive locking}: \textit{busy waiting, conditional waiting or critical sections}.
Infelizmente,\textit{locks} podem gerar atrasos arbitrários em qualquer uma das partes participantes. 

Tentando resolver o problema de primitivas de sincronização tradicionais, Lamport introduziu os primeiros algoritmos para leitura e escrita concorrente sem a utilização de \textit{locks}. 
A ideia foi posteriormente desenvolvida em uma série de mecanismos que suportam wait-freedom. 

Wait-freedom garante que qualquer thread que acesse um objeto compartilhando vai completar sua operação em um número finito de passos, indepentemente da velocidade de execução do processo. Isso implica que uma thread termina em um número finito de passos, mesmo se outras threads estiverem lentas ou pararam de prosseguir completamente. 

Wait freedom é uma propriedade extremamente desejável quando existe a necessidade de trabalhar com threads que encontrar atrasos inesperados. Exatamente o caso da maioria das implementações de TOBs baseadas em consenso. 

Durante nossa pesquisa nós iremos transformar uma implementação baseada em sincronização de Treplica no equivalente te um wait-free Treplica. A performance da implementação será comparada utilizando um benchmark para avaliar a contribuição de wait-freedom com a performance de replicação ativa. 


 

%******************************************************************************
% Referências - Definidas no arquivo Relatorio.bib
 +-------------+

\bibliographystyle{IEEEtran}

\bibliography{Plan}


%******************************************************************************

\end{document}
