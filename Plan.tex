%% Adaptado de 
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% Traduzido para o congresso de IC da USP
%%*****************************************************************************
% Não modificar

\documentclass[twoside,conference,a4paper]{IEEEtran}

%******************************************************************************
% Não modificar
\usepackage{IEEEtsup} % Definições complementares e modificações.
\usepackage[latin1]{inputenc} % Disponibiliza acentos.
\usepackage[english,brazil]{babel}
%% Disponibiliza Inglês e Português do Brasil.
\usepackage{latexsym,amsfonts,amssymb} % Disponibiliza fontes adicionais.
\usepackage{theorem} 
\usepackage[cmex10]{amsmath} % Pacote matemático básico 
\usepackage{url} 
%\usepackage[portuges,brazil,english]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage[pagebackref=true,breaklinks=true,letterpaper=true,colorlinks,bookmarks=false]{hyperref}
\usepackage[tight,footnotesize]{subfigure} 
\usepackage[noadjust]{cite} % Disponibiliza melhorias em citações.
%%*****************************************************************************

\begin{document}
\selectlanguage{brazil}
\renewcommand{\IEEEkeywordsname}{Palavras-chave}

%%*****************************************************************************

\urlstyle{tt}
% Indicar o nome do autor e o curso/nível (grad-mestrado-doutorado-especial)
\title{Plano de Pesquisa}
\author{%
 \IEEEauthorblockN{Luísa Madeira Cardoso}
}

%%*****************************************************************************

\maketitle

%%*****************************************************************************
% Resumo do trabalho
\begin{abstract}
Este plano de pesquisa discorre sobre a proposta de otimização da ferramenta Treplica através da substituição de mecanismos de sincronização tradicionais por outros \textit{wait-free}. O objetivo final é comparar a desempenho das duas implementações e mensurar o impacto da mudança para o desempenho final da replicação ativa.

\end{abstract}

% Indique três palavras-chave que descrevem o trabalho
%\begin{IEEEkeywords}
% Palavras-chave
%\end{IEEEkeywords}

%%*****************************************************************************
% Modifique as seções de acordo com o seu projeto

\section{Introdução}
A replicação é um dos tópicos mais estudados na área de sistemas distribuídos. 
De modo geral o mecanismo é utilizado para prover tolerância a falhas ou melhorar a desempenho.

O termo \textit{state machine approach}\cite{lamport1978,lamport1984} é utilizado para designar métodos que utilizam a replicação para prover serviços tolerantes a falhas. A ideia fundamental por trás do conceito é simples: dado um conjunto de máquinas de estado que inicialmente se encontram em situações semelhantes, se um conjunto de comandos determinísticos for executado na mesma ordem em cada uma, então o estado final será o mesmo em todas\cite{schneider1990}. Deste modo, todas as instâncias de um serviço estarão replicadas consistentemente. 

Considerando que no âmbito de sistemas distribuídos a entrega dos comandos se dá por troca de mensagens, o desafio encontra-se então em garantir uma ordem global de recebimento das mesmas. A esta classe de algoritmos da-se o nome \textit{Total order broadcast}(TOB) ou \textit{Atomic broadcast}(ABCAST). 

Existem diversas implementações para o TOB \cite{schiper2004}. 
Algumas exploram a relação de equivalência ao problema de \textit{Consenso}\cite{chandra1996} e utilizam algoritmos como Paxos\cite{lamport1998} na solução.
Em linhas gerais o \textit{Consenso} se resume a garantir que processos cheguem a uma decisão comum e única, inclusive na presença de falhas.  

Treplica\cite{vieira2008} é uma ferramenta projetada para replicação ubíqua (transparente, relisiliente e eficiente) que utiliza uma implementação de \textit{Total order broadcast} baseada em
 \textit{Consenso} utilizando Paxos e Fast-Paxos\cite{lamport2006}. Este documento apresenta um plano de pesquisa para transformar uma implementação de Treplica baseada em sincronização em uma equivalente \textit{wait-free}.


\section{Trabalho Proposto}

Um dos aspectos  criticos para a desempenho  de qualquer implementação
de \textit{TOB} é o tratamento de concorrência. \textit{TOBs} precisam
lidar  com  diversos  eventos  concorrentes:  recepção/transmissão  de
mensagens, eventos de controle  e persistência de dados.  Normalmente,
a arquitetura  que organiza todo  este fluxo de eventos  assíncronos é
baseada em  múltiplos processos  ou \textit{threads}  que compartilham
estruturas   de  dados.   Invariavelmente   o   acesso  aos   recursos
compartilhados não  pode ser realizado  sem algum método  de controle,
visto  que  isso produziria  um  estado  inconsistente. Mecanismos  de
sincronização são  a principal  forma de coordenação  empregada nestes
cenários.   As   primitivas  básicas  de  sincronização   em  qualquer
linguagem  ou  sistema  operacional se  baseiam  em  \textit{exclusive
  locking}:    \textit{busy   waiting,    conditional   waiting}    ou
\textit{critical sections}.  Infelizmente,  \textit{locks} podem gerar
atrasos arbitrários em qualquer uma das partes participantes.

Para  procurar  resolver o  problema  de  primitivas de  sincronização
tradicionais,   Lamport~\cite{lamport77b}   introduziu  os   primeiros
algoritmos  para leitura  e escrita  concorrente sem  a utilização  de
\textit{locks}.    A  idéia   foi   posteriormente  desenvolvida   por
Herlihy\cite{herlihy1991}  em uma  série  de  mecanismos que  apoiam
\textit{wait-freedom}.  Uma  implementação  \textit{wait-free}  de  um
objeto  compartilhado garante  que  qualquer  processo pode  completar
qualquer operação em um número  finito de passos, independentemente da
velocidade de  execução de outros processos.   \textit{Wait-freedom} é
uma propriedade extremamente desejável  quando existe a necessidade de
trabalhar  com  \textit{threads}  que  podem se  deparar  com  atrasos
inesperados e ou falhas;  exatamente  o  caso  da maioria  das  implementações  de
\textit{TOBs} baseadas em consenso.

Durante  nossa  pesquisa,  iremos  transformar  uma  implementação  de
Treplica   baseada    em   sincronização   no   equivalente    de   um
\textit{wait-free} Treplica. A desempenho das duas implementações será
comparada utilizando um benchmark  (TPC-W) para avaliar a contribuição
de \textit{wait-freedom} no desempenho da replicação ativa.

 

%******************************************************************************
% Referências - Definidas no arquivo Relatorio.bib
 +-------------+

\bibliographystyle{IEEEtran}

\bibliography{Plan}


%******************************************************************************

\end{document}
